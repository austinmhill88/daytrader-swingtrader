"""
Data models for the trading system using Pydantic for validation.
"""
from pydantic import BaseModel, Field, field_validator
from typing import Optional, Dict, List
from datetime import datetime
from enum import Enum


class OrderSide(str, Enum):
    """Order side enumeration."""
    BUY = "buy"
    SELL = "sell"


class OrderType(str, Enum):
    """Order type enumeration."""
    MARKET = "market"
    LIMIT = "limit"
    STOP = "stop"
    STOP_LIMIT = "stop_limit"


class TimeInForce(str, Enum):
    """Time in force enumeration."""
    DAY = "day"
    GTC = "gtc"
    IOC = "ioc"
    FOK = "fok"


class Bar(BaseModel):
    """OHLCV bar data."""
    symbol: str
    ts: datetime
    open: float = Field(gt=0)
    high: float = Field(gt=0)
    low: float = Field(gt=0)
    close: float = Field(gt=0)
    volume: int = Field(ge=0)
    vwap: Optional[float] = None
    trade_count: Optional[int] = None
    
    @field_validator('high')
    @classmethod
    def validate_high(cls, v, info):
        """Ensure high is >= low and >= open/close."""
        values = info.data
        if 'low' in values and v < values['low']:
            raise ValueError('high must be >= low')
        return v


class OrderIntent(BaseModel):
    """Represents an order intent before execution."""
    symbol: str
    side: OrderSide
    qty: int = Field(gt=0)
    order_type: OrderType = OrderType.LIMIT
    limit_price: Optional[float] = Field(default=None, gt=0)
    stop_price: Optional[float] = Field(default=None, gt=0)
    time_in_force: TimeInForce = TimeInForce.DAY
    bracket: Optional[Dict[str, float]] = None  # {"stop_loss": x, "take_profit": y}
    strategy_name: Optional[str] = None
    reason: Optional[str] = None
    
    @field_validator('limit_price')
    @classmethod
    def validate_limit_price(cls, v, info):
        """Ensure limit price is provided for limit orders."""
        values = info.data
        if values.get('order_type') == OrderType.LIMIT and v is None:
            raise ValueError('limit_price required for limit orders')
        return v


class Position(BaseModel):
    """Represents a trading position."""
    symbol: str
    qty: int
    side: str  # "long" or "short"
    avg_entry_price: float = Field(gt=0)
    current_price: float = Field(gt=0)
    market_value: float
    cost_basis: float
    unrealized_pl: float
    unrealized_plpc: float  # unrealized P/L percentage
    qty_available: Optional[int] = None


class Signal(BaseModel):
    """Trading signal generated by a strategy."""
    symbol: str
    strategy_name: str
    strength: float = Field(ge=-1.0, le=1.0)  # -1 (strong sell) to +1 (strong buy)
    confidence: float = Field(ge=0.0, le=1.0)  # 0 (no confidence) to 1 (high confidence)
    reason: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    metadata: Optional[Dict] = None  # Additional strategy-specific data
    
    def is_buy_signal(self) -> bool:
        """Check if this is a buy signal."""
        return self.strength > 0
    
    def is_sell_signal(self) -> bool:
        """Check if this is a sell signal."""
        return self.strength < 0
    
    def signal_power(self) -> float:
        """Calculate overall signal power (strength * confidence)."""
        return abs(self.strength) * self.confidence


class Trade(BaseModel):
    """Represents a completed trade."""
    symbol: str
    side: OrderSide
    qty: int
    price: float
    timestamp: datetime
    commission: float = 0.0
    order_id: Optional[str] = None
    strategy_name: Optional[str] = None


class PerformanceMetrics(BaseModel):
    """Performance metrics for tracking."""
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    equity: float
    cash: float
    positions_value: float
    daily_pnl: float
    daily_pnl_pct: float
    total_pnl: float
    total_pnl_pct: float
    num_positions: int
    num_trades_today: int
    gross_exposure_pct: float
    net_exposure_pct: float
    max_drawdown_pct: float
    sharpe_ratio: Optional[float] = None
    win_rate: Optional[float] = None


class AlertMessage(BaseModel):
    """Alert message for notifications."""
    level: str  # "INFO", "WARNING", "ERROR", "CRITICAL"
    title: str
    message: str
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    metadata: Optional[Dict] = None
